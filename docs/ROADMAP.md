# RangePlotter Roadmap

## 1. Objectives
- Compute theoretical radar geometric range rings for specified target altitudes using Earth curvature + atmospheric refraction adjustments.
- Refine each ring via terrain-aware line-of-sight (viewshed) using Copernicus GLO-30 DEM to produce polygons of actual visibility per altitude per radar.
- **New Feature**: `detection-range` command to clip viewsheds to a maximum instrumented range.
- Output KML/KMZ files organized in a logical directory structure for Google Earth Pro.
- Provide a modular, extensible Python codebase.

## 2. Architecture
- `rangeplotter` package structure.
- `io.export`: Handles KML generation. **Updated to produce self-contained KMLs with sensor location and viewshed.**
- `cli`: `horizon`, `viewshed`, `detection-range`.

## 3. Current Status
- **Core**: Basic viewshed and horizon calculation implemented.
- **DEM**: Copernicus GLO-30 integration working.
- **Export**: Basic KML polygon export.

## 4. Performance Optimization
### Feature: Memory-Efficient DEM Reprojection
**Goal**: Optimize the `viewshed` command's "Reprojecting DEM" stage to reduce memory usage and improve CPU utilization. Currently, it merges all DEM tiles into a large in-memory array before reprojection, which is memory-bound and inefficient.

**Implementation Plan**:
1.  **Refactor `_reproject_dem_to_aeqd`**:
    *   Remove the `rasterio.merge.merge` step which creates a monolithic source array.
    *   Allocate the destination AEQD array (using disk-swap if necessary, as currently implemented).
    *   Iterate through each source DEM tile:
        *   Open the tile.
        *   Reproject the tile directly into the destination array using `rasterio.warp.reproject`.
        *   Use `num_threads` to enable multi-threaded processing during reprojection.
    *   This approach mimics the memory benefits of a Virtual Raster (VRT) by avoiding the intermediate mosaic.

2.  **Concurrency**:
    *   Ensure `reproject` is called with appropriate threading options (e.g., `num_threads=-1` for all cores).

### Feature: Adaptive DEM Resolution & Instrumentation
**Goal**: Further reduce memory usage and processing time for long-range viewsheds by adaptively switching to a coarser DEM resolution (e.g., 90m) when the analysis radius exceeds a configurable threshold. Additionally, add detailed performance logging to identify bottlenecks.

**Implementation Plan**:
1.  **Configuration**:
    *   Add `dem_resolution_threshold_km` to `config.yaml` (default: 100 km).
    *   Add `coarse_resolution_m` to `config.yaml` (default: 90.0 m).
    *   Add `fine_resolution_m` to `config.yaml` (default: 30.0 m).

2.  **Instrumentation**:
    *   Add `time.perf_counter()` logging around key steps in `viewshed.py`:
        *   VRT Creation.
        *   Reprojection (Warp).
        *   Visibility Sweep (Total).
        *   Polygon Vectorization.

3.  **Adaptive Resolution Logic**:
    *   Modify `_reproject_dem_to_aeqd` to accept a target resolution.
    *   In `compute_viewshed`, check `max_radius_m` against `dem_resolution_threshold_km`.
    *   Select `target_res` (30m vs 90m) accordingly.
    *   Pass this resolution to the reprojection function.

## 5. Detection Range Workflow
**Goal**: Clip "raw" geometric viewsheds to specific maximum instrumented ranges to simulate real-world radar performance.

**Command**: `detection-range`

**Inputs**:
1.  **Viewshed Files** (`--input`): One or more KML files generated by the `viewshed` command.
2.  **Detection Ranges** (`--range`): A list of maximum ranges in km (e.g., `100,200`). Defaults to `config.yaml`.
3.  **Output Name** (`--name`): Optional name for the output group (defaults to sensor name for single-site inputs).

**Logic**:
1.  **Parsing**:
    *   Load input KMLs.
    *   Extract Sensor Location (Point) and Viewshed (Polygon/MultiPolygon).
    *   Group inputs by **Target Altitude**.

2.  **Processing**:
    *   For each **Target Altitude** and each **Detection Range**:
        *   **Clip**: Intersect the raw viewshed polygon with a geodesic buffer (circle) of the detection radius around the sensor.
        *   **Union (Multi-Sensor)**: If multiple sensors are present for the same altitude, compute the geometric union of their clipped polygons.

3.  **Output**:
    *   **Structure**: `output/detection_range/[name]/`
    *   **Filenames**: `visibility-[name]-tgt_alt_[alt]m-det_rng_[rng]km.kml`
    *   **Single Sensor**: `[name]` is the sensor site name.
    *   **Multi-Sensor**: `[name]` is the provided `--name` (e.g., "North_Network") or "Union".

## 6. AGL Target Support (New Feature)
**Goal**: Allow users to calculate viewsheds for targets at a constant height Above Ground Level (AGL), in addition to the existing Mean Sea Level (MSL) support. This is critical for low-altitude analysis (e.g., drones, ground vehicles) where visibility is determined by terrain masking relative to the surface.

**Status**: **Planned**.

**Implementation Plan**:

1.  **Configuration & CLI**:
    *   **Config**: Utilize the existing `vertical.target_altitude_reference` setting in `config.yaml`. Allow values `"msl"` (default) and `"agl"`.
    *   **CLI**: Add a `--ref` or `--reference` flag to the `viewshed` command to override the config (e.g., `--ref agl`).
    *   **Validation**: Ensure the user is aware of which mode is active via logging.

2.  **Core Logic (`src/rangeplotter/los/viewshed.py`)**:
    *   Modify `compute_viewshed` to accept an `altitude_mode` parameter.
    *   **Refactor the Radial Sweep Loop**:
        *   Current (MSL): `target_h` is a constant scalar. `theta_target` is calculated against this constant plane.
        *   New (AGL): `target_h` varies with terrain.
            *   `target_elevation_grid = terrain_elevation + target_altitude_agl`
            *   `theta_target` is calculated using this dynamic grid.
    *   **Performance**: This change involves array-based arithmetic for the target angle, which is computationally equivalent to the existing terrain angle calculation. No significant performance penalty is expected.

3.  **Output Naming**:
    *   Update filename generation to explicitly include the reference frame to avoid ambiguity.
    *   Format: `[Site]_[Altitude]m_[Ref]_viewshed.kml` (e.g., `Site_100.0m_AGL_viewshed.kml`).
    *   *Note*: Consider updating existing MSL output to include `_MSL` for consistency, or keep legacy format for MSL. (Decision: Explicit `_MSL` / `_AGL` is preferred for clarity).

4.  **Subtleties & Edge Cases**:
    *   **0m AGL**: Equivalent to checking visibility of the ground surface itself.
    *   **Underground Targets**: For AGL, targets are by definition above ground (if alt >= 0), so the "underground check" (`target < terrain`) is implicitly satisfied.
    *   **Refraction**: The standard 4/3 Earth radius model (or configured k-factor) will apply to the path `Sensor -> (Terrain + AGL)` exactly as it does for `Sensor -> Terrain`.

## 7. Packaging & Distribution
**Goal**: Package the utility for easy distribution to Linux users without requiring them to manage Python environments or complex GDAL dependencies.

**Strategy**: **Standalone Binary via PyInstaller**.
This approach bundles the Python interpreter, application code, and all dependencies (including GDAL/Rasterio) into a single executable file. Users can download it directly from GitHub Releases, make it executable, and run it.

**Status**: **Implemented**.
- PyInstaller spec file created and verified.
- GitHub Actions workflow configured to build and release binaries on tags.
- **Updated**: Release process now packages the binary in a ZIP archive with editable config and data folders.

**Implementation Steps**:
1.  **Dependency Analysis** (Done):
    *   Verify `pyinstaller` compatibility with `rasterio` and `typer`.
    *   Identify necessary hidden imports and binary data (GDAL data files).
2.  **Build Configuration** (Done):
    *   Create a `rangeplotter.spec` file to define the build process.
    *   Ensure `gdal-data` and `proj-data` are correctly bundled and environment variables are set at runtime.
3.  **GitHub Actions Workflow** (Done):
    *   Create a workflow `.github/workflows/build.yml` to automate the build on new tags.
    *   Step 1: Checkout code.
    *   Step 2: Install system dependencies (GDAL, etc.) on the runner.
    *   Step 3: Build binary with PyInstaller.
    *   Step 4: Upload binary as a release asset.
4.  **Snap Package (Secondary)**:
    *   Once the binary build is stable, consider wrapping it in a `snap` for the Canonical Store.
    *   Create `snap/snapcraft.yaml`.

### Feature: Portable Archive Release
**Goal**: Repackage the application so that users can easily access and modify configuration files and input data without needing to rebuild the binary. The current single-file binary hides `config.yaml` and `working_files`, making it difficult for end-users to configure the tool.

**Status**: **Implemented**.

**Implementation Plan**:

1.  **Configuration Loading Logic (`src/rangeplotter/config/settings.py`)** (Done):
    *   Modify the `load_settings` (or equivalent) function to search for `config.yaml` in the following priority order:
        1.  **Current Working Directory**: `./config/config.yaml` (Priority 1 - User overrides).
        2.  **Executable Directory**: `{exe_dir}/config/config.yaml` (Priority 2 - Portable install).
        3.  **Internal Fallback**: The bundled default config (Priority 3 - Safety net).
    *   Ensure that default paths for `working_files`, `cache_dir`, etc., in the config are resolved relative to the *location of the config file* or the *executable*, rather than hardcoded absolute paths or internal temp directories.

2.  **Release Artifact Structure** (Done):
    *   Define the standard release format as a ZIP archive containing:
        ```text
        rangeplotter_vX.Y.Z/
        ├── rangeplotter          (The executable binary)
        ├── README.md             (Documentation)
        ├── LICENSE               (License file)
        ├── config/
        │   └── config.yaml       (Default user-editable config)
        └── working_files/
            ├── input/            (Empty or with sample data)
            ├── output/           (Placeholder)
            └── ...
        ```

3.  **Build Process Update** (Done):
    *   Update `docs/RELEASE_PROCESS.md` to include the steps for creating this archive.
    *   (Optional) Create a helper script `scripts/build_release.sh` to:
        1.  Run PyInstaller.
        2.  Create the directory structure.
        3.  Copy the binary, config, and readme.
        4.  Zip the result.

4.  **Verification** (Done):
    *   Test running the binary from a clean directory with an external `config/config.yaml`.
    *   Verify that changes to the external config (e.g., changing `output_dir`) are respected by the binary.

## 5. Documentation & Housekeeping
    *   **Update README.md** (Done):
        *   Revise the "Installation" section to reflect the new Zip archive format.
        *   Explain the directory structure (binary, config, working_files).
        *   Clarify that users should edit `config/config.yaml` to change settings.
    *   **Update .gitignore** (Done): Ensure the new release artifacts (zip files, release folders) are ignored.
    *   **Clean up** (Done): Remove any obsolete build artifacts or temporary files.

## 7. Future Work
- Union polygons across multiple radars.
- Advanced propagation modeling.
- Web UI.
