# RangePlotter Roadmap

## 1. Objectives
- Compute theoretical radar geometric range rings for specified target altitudes using Earth curvature + atmospheric refraction adjustments.
- Refine each ring via terrain-aware line-of-sight (viewshed) using Copernicus GLO-30 DEM to produce polygons of actual visibility per altitude per radar.
- **New Feature**: `detection-range` command to clip viewsheds to a maximum instrumented range.
- Output KML/KMZ files organized in a logical directory structure for Google Earth Pro.
- Provide a modular, extensible Python codebase.

## 2. Architecture
- `rangeplotter` package structure.
- `io.export`: Handles KML generation. **Updated to produce self-contained KMLs with sensor location and viewshed.**
- `cli`: `horizon`, `viewshed`, `detection-range`.

## 3. Current Status
- **Core**: Basic viewshed and horizon calculation implemented.
- **DEM**: Copernicus GLO-30 integration working.
- **Export**: Basic KML polygon export.

## 4. Performance Optimization
### Feature: Memory-Efficient DEM Reprojection
**Goal**: Optimize the `viewshed` command's "Reprojecting DEM" stage to reduce memory usage and improve CPU utilization. Currently, it merges all DEM tiles into a large in-memory array before reprojection, which is memory-bound and inefficient.

**Implementation Plan**:
1.  **Refactor `_reproject_dem_to_aeqd`**:
    *   Remove the `rasterio.merge.merge` step which creates a monolithic source array.
    *   Allocate the destination AEQD array (using disk-swap if necessary, as currently implemented).
    *   Iterate through each source DEM tile:
        *   Open the tile.
        *   Reproject the tile directly into the destination array using `rasterio.warp.reproject`.
        *   Use `num_threads` to enable multi-threaded processing during reprojection.
    *   This approach mimics the memory benefits of a Virtual Raster (VRT) by avoiding the intermediate mosaic.

2.  **Concurrency**:
    *   Ensure `reproject` is called with appropriate threading options (e.g., `num_threads=-1` for all cores).

### Feature: Adaptive DEM Resolution & Instrumentation
**Goal**: Further reduce memory usage and processing time for long-range viewsheds by adaptively switching to a coarser DEM resolution (e.g., 90m) when the analysis radius exceeds a configurable threshold. Additionally, add detailed performance logging to identify bottlenecks.

**Implementation Plan**:
1.  **Configuration**:
    *   Add `dem_resolution_threshold_km` to `config.yaml` (default: 100 km).
    *   Add `coarse_resolution_m` to `config.yaml` (default: 90.0 m).
    *   Add `fine_resolution_m` to `config.yaml` (default: 30.0 m).

2.  **Instrumentation**:
    *   Add `time.perf_counter()` logging around key steps in `viewshed.py`:
        *   VRT Creation.
        *   Reprojection (Warp).
        *   Visibility Sweep (Total).
        *   Polygon Vectorization.

3.  **Adaptive Resolution Logic**:
    *   Modify `_reproject_dem_to_aeqd` to accept a target resolution.
    *   In `compute_viewshed`, check `max_radius_m` against `dem_resolution_threshold_km`.
    *   Select `target_res` (30m vs 90m) accordingly.
    *   Pass this resolution to the reprojection function.

## 5. Detection Range Workflow
**Goal**: Clip "raw" geometric viewsheds to specific maximum instrumented ranges to simulate real-world radar performance.

**Command**: `detection-range`

**Inputs**:
1.  **Viewshed Files** (`--input`): One or more KML files generated by the `viewshed` command.
2.  **Detection Ranges** (`--range`): A list of maximum ranges in km (e.g., `100,200`). Defaults to `config.yaml`.
3.  **Output Name** (`--name`): Optional name for the output group (defaults to sensor name for single-site inputs).

**Logic**:
1.  **Parsing**:
    *   Load input KMLs.
    *   Extract Sensor Location (Point) and Viewshed (Polygon/MultiPolygon).
    *   Group inputs by **Target Altitude**.

2.  **Processing**:
    *   For each **Target Altitude** and each **Detection Range**:
        *   **Clip**: Intersect the raw viewshed polygon with a geodesic buffer (circle) of the detection radius around the sensor.
        *   **Union (Multi-Sensor)**: If multiple sensors are present for the same altitude, compute the geometric union of their clipped polygons.

3.  **Output**:
    *   **Structure**: `output/detection_range/[name]/`
    *   **Filenames**: `visibility-[name]-tgt_alt_[alt]m-det_rng_[rng]km.kml`
    *   **Single Sensor**: `[name]` is the sensor site name.
    *   **Multi-Sensor**: `[name]` is the provided `--name` (e.g., "North_Network") or "Union".

## 6. Future Work
- Union polygons across multiple radars.
- Advanced propagation modeling.
- Web UI.
