# RangePlotter Roadmap

## 1. Objectives
- Compute theoretical radar geometric range rings for specified target altitudes using Earth curvature + atmospheric refraction adjustments.
- Refine each ring via terrain-aware line-of-sight (viewshed) using Copernicus GLO-30 DEM to produce polygons of actual visibility per altitude per radar.
- **New Feature**: `detection-range` command to clip viewsheds to a maximum instrumented range.
- Output KML/KMZ files organized in a logical directory structure for Google Earth Pro.
- Provide a modular, extensible Python codebase.

## 2. Architecture
- `rangeplotter` package structure.
- `io.export`: Handles KML generation. **Updated to produce self-contained KMLs with sensor location and viewshed.**
- `cli`: `horizon`, `viewshed`, `detection-range`.

## 3. Current Status
- **Core**: Basic viewshed and horizon calculation implemented.
- **DEM**: Copernicus GLO-30 integration working.
- **Export**: Basic KML polygon export.

## 4. Performance Optimization
### Feature: Memory-Efficient DEM Reprojection
**Goal**: Optimize the `viewshed` command's "Reprojecting DEM" stage to reduce memory usage and improve CPU utilization. Currently, it merges all DEM tiles into a large in-memory array before reprojection, which is memory-bound and inefficient.

**Implementation Plan**:
1.  **Refactor `_reproject_dem_to_aeqd`**:
    *   Remove the `rasterio.merge.merge` step which creates a monolithic source array.
    *   Allocate the destination AEQD array (using disk-swap if necessary, as currently implemented).
    *   Iterate through each source DEM tile:
        *   Open the tile.
        *   Reproject the tile directly into the destination array using `rasterio.warp.reproject`.
        *   Use `num_threads` to enable multi-threaded processing during reprojection.
    *   This approach mimics the memory benefits of a Virtual Raster (VRT) by avoiding the intermediate mosaic.

2.  **Concurrency**:
    *   Ensure `reproject` is called with appropriate threading options (e.g., `num_threads=-1` for all cores).

### Feature: Adaptive DEM Resolution & Instrumentation
**Goal**: Further reduce memory usage and processing time for long-range viewsheds by adaptively switching to a coarser DEM resolution (e.g., 90m) when the analysis radius exceeds a configurable threshold. Additionally, add detailed performance logging to identify bottlenecks.

**Implementation Plan**:
1.  **Configuration**:
    *   Add `dem_resolution_threshold_km` to `config.yaml` (default: 100 km).
    *   Add `coarse_resolution_m` to `config.yaml` (default: 90.0 m).
    *   Add `fine_resolution_m` to `config.yaml` (default: 30.0 m).

2.  **Instrumentation**:
    *   Add `time.perf_counter()` logging around key steps in `viewshed.py`:
        *   VRT Creation.
        *   Reprojection (Warp).
        *   Visibility Sweep (Total).
        *   Polygon Vectorization.

3.  **Adaptive Resolution Logic**:
    *   Modify `_reproject_dem_to_aeqd` to accept a target resolution.
    *   In `compute_viewshed`, check `max_radius_m` against `dem_resolution_threshold_km`.
    *   Select `target_res` (30m vs 90m) accordingly.
    *   Pass this resolution to the reprojection function.

## 5. Detection Range Workflow
**Goal**: Clip "raw" geometric viewsheds to specific maximum instrumented ranges to simulate real-world radar performance.

**Command**: `detection-range`

**Inputs**:
1.  **Viewshed Files** (`--input`): One or more KML files generated by the `viewshed` command.
2.  **Detection Ranges** (`--range`): A list of maximum ranges in km (e.g., `100,200`). Defaults to `config.yaml`.
3.  **Output Name** (`--name`): Optional name for the output group (defaults to sensor name for single-site inputs).

**Logic**:
1.  **Parsing**:
    *   Load input KMLs.
    *   Extract Sensor Location (Point) and Viewshed (Polygon/MultiPolygon).
    *   Group inputs by **Target Altitude**.

2.  **Processing**:
    *   For each **Target Altitude** and each **Detection Range**:
        *   **Clip**: Intersect the raw viewshed polygon with a geodesic buffer (circle) of the detection radius around the sensor.
        *   **Union (Multi-Sensor)**: If multiple sensors are present for the same altitude, compute the geometric union of their clipped polygons.

3.  **Output**:
    *   **Structure**: `output/detection_range/[name]/`
    *   **Filenames**: `rangeplotter-[name]-tgt_alt_[alt]m-det_rng_[rng]km.kml`
    *   **Single Sensor**: `[name]` is the sensor site name.
    *   **Multi-Sensor**: `[name]` is the provided `--name` (e.g., "North_Network") or "Union".

## 6. AGL Target Support (New Feature)
**Goal**: Allow users to calculate viewsheds for targets at a constant height Above Ground Level (AGL), in addition to the existing Mean Sea Level (MSL) support. This is critical for low-altitude analysis (e.g., drones, ground vehicles) where visibility is determined by terrain masking relative to the surface.

**Status**: **Planned**.

**Implementation Plan**:

1.  **Configuration & CLI**:
    *   **Config**: Utilize the existing `vertical.target_altitude_reference` setting in `config.yaml`. Allow values `"msl"` (default) and `"agl"`.
    *   **CLI**: Add a `--ref` or `--reference` flag to the `viewshed` command to override the config (e.g., `--ref agl`).
    *   **Validation**: Ensure the user is aware of which mode is active via logging.

2.  **Core Logic (`src/rangeplotter/los/viewshed.py`)**:
    *   Modify `compute_viewshed` to accept an `altitude_mode` parameter.
    *   **Refactor the Radial Sweep Loop**:
        *   Current (MSL): `target_h` is a constant scalar. `theta_target` is calculated against this constant plane.
        *   New (AGL): `target_h` varies with terrain.
            *   `target_elevation_grid = terrain_elevation + target_altitude_agl`
            *   `theta_target` is calculated using this dynamic grid.
    *   **Performance**: This change involves array-based arithmetic for the target angle, which is computationally equivalent to the existing terrain angle calculation. No significant performance penalty is expected.

3.  **Output Naming**:
    *   Update filename generation to explicitly include the reference frame to avoid ambiguity.
    *   Format: `[Site]_[Altitude]m_[Ref]_viewshed.kml` (e.g., `Site_100.0m_AGL_viewshed.kml`).
    *   *Note*: Consider updating existing MSL output to include `_MSL` for consistency, or keep legacy format for MSL. (Decision: Explicit `_MSL` / `_AGL` is preferred for clarity).

4.  **Subtleties & Edge Cases**:
    *   **0m AGL**: Equivalent to checking visibility of the ground surface itself.
    *   **Underground Targets**: For AGL, targets are by definition above ground (if alt >= 0), so the "underground check" (`target < terrain`) is implicitly satisfied.
    *   **Refraction**: The standard 4/3 Earth radius model (or configured k-factor) will apply to the path `Sensor -> (Terrain + AGL)` exactly as it does for `Sensor -> Terrain`.

## 7. Packaging & Distribution
**Goal**: Provide robust, flexible distribution options for both end-users (Linux binary) and developers (Python package), while ensuring a smooth upgrade path.

### Feature: Hybrid Distribution Model
**Goal**: Offer both a "Frozen Binary" for ease of use and a "Python Wheel" for flexibility and code inspection.

**Status**: **Planned for v0.1.5**.

**Implementation Plan**:
1.  **Python Wheel (.whl)**:
    *   **Build**: Use `poetry build` or `python -m build` to generate a standard wheel file (e.g., `rangeplotter-0.1.5-py3-none-any.whl`).
    *   **CI/CD**: Update GitHub Actions to build and upload this artifact alongside the binary zip.
    *   **Benefit**: Allows developers to `pip install` the tool into their own environments, solving dependency issues on non-Linux platforms and enabling code inspection.

2.  **Release Candidate Workflow**:
    *   **Methodology**: Adopt a pre-release testing cycle using tags like `v0.1.5-rc1`.
    *   **CI Logic**: Update build workflows to detect `-rc` tags and mark releases as "Pre-release" on GitHub.
    *   **Benefit**: Enables testing of the *packaged* application before general availability.

### Feature: Graceful Upgrade Capability
**Goal**: Allow users to upgrade the application binary without overwriting their configuration or data.

**Status**: **Planned for v0.1.5**.

**Implementation Plan**:
1.  **Upgrade Script (Solution B)**:
    *   Include an `install_or_upgrade.sh` script in the release zip.
    *   Document the process for Linux/Windows/Mac in the readme, including recommendation to backup files (copy to xxx.backup) before upgrading.
    *   **Logic**:
        *   Prompt user for install location.
        *   Copy the new `rangeplotter` binary.
        *   Check for existing `config/config.yaml`. If found, do *not* overwrite.
        *   (Optional) Check for new config keys and append them to the existing file if missing.
        *   Ensure user's `.env` remains intact.
        *   
    *   **Config Strategy**: No changes to `config.yaml` structure or location logic. The application will continue to look for config in the executable directory or CWD.
